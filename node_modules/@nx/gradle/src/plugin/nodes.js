"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeCreateNodesForGradleConfigFile = exports.createNodesV2 = void 0;
exports.writeTargetsToCache = writeTargetsToCache;
const devkit_1 = require("@nx/devkit");
const calculate_hash_for_create_nodes_1 = require("@nx/devkit/src/utils/calculate-hash-for-create-nodes");
const node_fs_1 = require("node:fs");
const node_path_1 = require("node:path");
const cache_directory_1 = require("nx/src/utils/cache-directory");
const file_hasher_1 = require("nx/src/hasher/file-hasher");
const split_config_files_1 = require("../utils/split-config-files");
const get_project_graph_from_gradle_plugin_1 = require("./utils/get-project-graph-from-gradle-plugin");
const gradle_plugin_options_1 = require("./utils/gradle-plugin-options");
function readProjectsCache(cachePath) {
    return (0, node_fs_1.existsSync)(cachePath) ? (0, devkit_1.readJsonFile)(cachePath) : {};
}
function writeTargetsToCache(cachePath, results) {
    (0, devkit_1.writeJsonFile)(cachePath, results);
}
exports.createNodesV2 = [
    split_config_files_1.gradleConfigAndTestGlob,
    async (files, options, context) => {
        const { buildFiles, gradlewFiles } = (0, split_config_files_1.splitConfigFiles)(files);
        const optionsHash = (0, file_hasher_1.hashObject)(options);
        const cachePath = (0, node_path_1.join)(cache_directory_1.workspaceDataDirectory, `gradle-${optionsHash}.hash`);
        const projectsCache = readProjectsCache(cachePath);
        await (0, get_project_graph_from_gradle_plugin_1.populateProjectGraph)(context.workspaceRoot, gradlewFiles.map((f) => (0, node_path_1.join)(context.workspaceRoot, f)), options);
        const { nodes, externalNodes } = (0, get_project_graph_from_gradle_plugin_1.getCurrentProjectGraphReport)();
        try {
            return (0, devkit_1.createNodesFromFiles)((0, exports.makeCreateNodesForGradleConfigFile)(nodes, projectsCache, externalNodes), buildFiles, options, context);
        }
        finally {
            writeTargetsToCache(cachePath, projectsCache);
        }
    },
];
const makeCreateNodesForGradleConfigFile = (projects, projectsCache = {}, externalNodes = {}) => async (gradleFilePath, options, context) => {
    if (process.env.VERCEL) {
        // Vercel does not allow JAVA_VERSION to be set
        // skip on Vercel
        return {};
    }
    const projectRoot = (0, node_path_1.dirname)(gradleFilePath);
    options = (0, gradle_plugin_options_1.normalizeOptions)(options);
    const hash = await (0, calculate_hash_for_create_nodes_1.calculateHashForCreateNodes)(projectRoot, options ?? {}, context);
    projectsCache[hash] ??=
        projects[projectRoot] ?? projects[(0, node_path_1.join)(devkit_1.workspaceRoot, projectRoot)];
    const project = projectsCache[hash];
    if (!project) {
        return {};
    }
    project.root = projectRoot;
    return {
        projects: {
            [projectRoot]: project,
        },
        externalNodes: externalNodes,
    };
};
exports.makeCreateNodesForGradleConfigFile = makeCreateNodesForGradleConfigFile;
