export interface GradleReport {
    gradleFileToGradleProjectMap: Map<string, string>;
    gradleFileToOutputDirsMap: Map<string, Map<string, string>>;
    gradleProjectToDepsMap: Map<string, Set<string>>;
    gradleProjectToTasksTypeMap: Map<string, Map<string, string>>;
    gradleProjectToTasksMap: Map<string, Set<string>>;
    gradleProjectToProjectName: Map<string, string>;
    gradleProjectNameToProjectRootMap: Map<string, string>;
    gradleProjectToChildProjects: Map<string, string[]>;
}
export interface GradleReportJSON {
    hash: string;
    gradleFileToGradleProjectMap: Record<string, string>;
    gradleProjectToDepsMap: Record<string, Array<string>>;
    gradleFileToOutputDirsMap: Record<string, Record<string, string>>;
    gradleProjectToTasksTypeMap: Record<string, Record<string, string>>;
    gradleProjectToTasksMap: Record<string, Array<string>>;
    gradleProjectToProjectName: Record<string, string>;
    gradleProjectNameToProjectRootMap: Record<string, string>;
    gradleProjectToChildProjects: Record<string, string[]>;
}
export declare function writeGradleReportToCache(cachePath: string, results: GradleReport): void;
export declare function getCurrentGradleReport(): GradleReport;
/**
 * This function populates the gradle report cache.
 * For each gradlew file, it runs the `projectReportAll` task and processes the output.
 * If `projectReportAll` fails, it runs the `projectReport` task instead.
 * It will throw an error if both tasks fail.
 * It will accumulate the output of all gradlew files.
 * @param workspaceRoot
 * @param gradlewFiles absolute paths to all gradlew files in the workspace
 * @returns Promise<void>
 */
export declare function populateGradleReport(workspaceRoot: string, gradlewFiles: string[]): Promise<void>;
export declare function processProjectReports(projectReportLines: string[]): GradleReport;
export declare function processGradleDependencies(depsFile: string): Set<string>;
